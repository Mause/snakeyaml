= SnakeYAML Documentation =

''This documentation is very brief and incomplete. Feel free to fix or improve it.''


[[PageOutline]]


== Installation ==

Download the source package and put it to the classpath. 

Note that there are some subtle (but not really significant) differences between [http://pyyaml.org/wiki/PyYAML Python] and [http://trac-hg.assembla.com/snakeyaml/wiki SnakeYaml] parsers
and emitters.

== Frequently Asked Questions ==

=== Dictionaries without nested collections are not dumped correctly ===

''Why does''
{{{
Yaml yaml = new Yaml();
String document = "  a: 1\n  b:\n    c: 3\n    d: 4\n";
System.out.println(document);
System.out.println(yaml.dump(yaml.load(document)));
}}}
''give''
{{{
  a: 1
  b:
    c: 3
    d: 4

a: 1
b: {c: 3, d: 4}
}}}

It's a correct output despite the fact that the style of the nested mapping is different.

By default, SnakeYAML chooses the style of a collection depending on whether it has nested
collections. If a collection has nested collections, it will be assigned the block style.
Otherwise it will have the flow style.

If you want collections to be always serialized in the block style, set the parameter
'''`defaultFlowStyle`''' of '''`DumperOptions`''' to '''`false`'''. For instance,
{{{
DumperOptions options = new DumperOptions();
options.setDefaultFlowStyle(false);
Yaml yaml = new Yaml(options);
String document = "  a: 1\n  b:\n    c: 3\n    d: 4\n";
System.out.println(yaml.dump(yaml.load(document)));

a: 1
b:
  c: 3
  d: 4
}}}

You can find an example [http://trac-hg.assembla.com/snakeyaml/browser/src/test/java/examples/CollectionStyleTest.java here]

== Tutorial ==

Start with instantiating the '''`org.yaml.snakeyaml.Yaml`''' instance.

{{{
Yaml yaml = new Yaml();
}}}


=== Loading YAML ===

The method '''`Yaml.load()`''' converts a YAML document to a Java object.

{{{
Yaml yaml = new Yaml();
String document = "\n- Hesperiidae\n- Papilionidae\n- Apatelodidae\n- Epiplemidae";
List<String> list = (List<String>) yaml.load(document);
System.out.println(list);

['Hesperiidae', 'Papilionidae', 'Apatelodidae', 'Epiplemidae']
}}}
You can find an example [http://trac-hg.assembla.com/snakeyaml/browser/src/test/java/examples/LoadExampleTest.java here]

'''`Yaml.load()`''' accepts a String or
an InputStream object. '''`Yaml.load()`''' detects the encoding
by checking the '''BOM''' (byte order mark) sequence at the beginning of the
String/stream. If no '''BOM''' is present, the '''utf-8''' encoding is assumed.

'''`Yaml.load()`''' returns a Java object.

{{{
    public void testLoadFromString() {
        Yaml yaml = new Yaml();
        String document = "hello: 25";
        Map map = (Map) yaml.load(document);
        assertEquals("{hello=25}", map.toString());
        assertEquals(new Long(25), map.get("hello"));
    }

    public void testLoadFromStream() throws FileNotFoundException {
        InputStream input = new FileInputStream(new File("src/test/resources/reader/utf-8.txt"));
        Yaml yaml = new Yaml();
        Object data = yaml.load(input);
        assertEquals("test", data);
        //
        data = yaml.load(new ByteArrayInputStream("test2".getBytes()));
        assertEquals("test2", data);
    }
}}}

If a String or a stream contains several documents, you may load them all with the
'''`Yaml.loadAll()`''' method.
{{{
---
Time: 2001-11-23 15:01:42 -5
User: ed
Warning:
  This is an error message
  for the log file
---
Time: 2001-11-23 15:02:31 -5
User: ed
Warning:
  A slightly different error
  message.
---
Date: 2001-11-23 15:03:17 -5
User: ed
Fatal:
  Unknown variable "bar"
Stack:
  - file: TopClass.py
    line: 23
    code: |
      x = MoreObject("345\n")
  - file: MoreClass.py
    line: 58
    code: |-
      foo = bar
}}}
{{{
public void testLoadManyDocuments() throws FileNotFoundException {
        InputStream input = new FileInputStream(new File(
                "src/test/resources/specification/example2_28.yaml"));
        Yaml yaml = new Yaml();
        int counter = 0;
        for (Object data : yaml.loadAll(input)) {
            System.out.println(data);
            counter++;
        }
        assertEquals(3, counter);
}
}}}
{{{
{Time=Fri Nov 23 21:01:42 CET 2001, User=ed, Warning=This is an error message for the log file}
{Time=Fri Nov 23 21:02:31 CET 2001, User=ed, Warning=A slightly different error message.}
{Date=Fri Nov 23 21:03:17 CET 2001, User=ed, Fatal=Unknown variable "bar", Stack=[{file=TopClass.py, line=23, code=x = MoreObject("345\n")
}, {file=MoreClass.py, line=58, code=foo = bar}]}
}}}

SnakeYAML allows you [http://trac-hg.assembla.com/snakeyaml/browser/src/test/java/examples/AnyObjectExampleTest.java to construct] a Java object of any type.

{{{
none: [~, null]
bool: [true, false, on, off]
int: 42
float: 3.14159
list: [LITE, RES_ACID, SUS_DEXT]
dict: {hp: 13, sp: 5}
}}}

{{{
    public void testLoad() throws IOException {
        String doc = Util.getLocalResource("examples/any-object-example.yaml");
        Yaml yaml = new Yaml();
        Map<String, Object> object = (Map<String, Object>) yaml.load(doc);
        System.out.println(object);
    }
}}}
{{{
{none=[null, null], bool=[true, false, true, false], int=42, float=3.14159, 
list=[LITE, RES_ACID, SUS_DEXT], dict={hp=13, sp=5}}
}}}

Even instances of Java classes can be constructed using the '''`!!python/object`''' tag.
{{{
#!python
>>> class Hero:
...     def __init__(self, name, hp, sp):
...         self.name = name
...         self.hp = hp
...         self.sp = sp
...     def __repr__(self):
...         return "%s(name=%r, hp=%r, sp=%r)" % (
...             self.__class__.__name__, self.name, self.hp, self.sp)

>>> yaml.load("""
... !!python/object:__main__.Hero
... name: Welthyr Syxgon
... hp: 1200
... sp: 0
... """)

Hero(name='Welthyr Syxgon', hp=1200, sp=0)
}}}

Note that the ability to construct an arbitrary Python object may be dangerous
if you receive a YAML document from an untrusted source such as Internet.
The function '''`yaml.safe_load`''' limits this ability to simple Python objects
like integers or lists.


=== Dumping YAML ===

The '''`yaml.dump`''' function accepts a Java object and produces a YAML document.
{{{
#!python
>>> print yaml.dump({'name': 'Silenthand Olleander', 'race': 'Human',
... 'traits': ['ONE_HAND', 'ONE_EYE']})

name: Silenthand Olleander
race: Human
traits: [ONE_HAND, ONE_EYE]
}}}

'''`yaml.dump`''' accepts the second optional argument, which must be an open file.
In this case, '''`yaml.dump`''' will write the produced YAML document into the file.
Otherwise, '''`yaml.dump`''' returns the produced document.

{{{
#!python
>>> stream = file('document.yaml', 'w')
>>> yaml.dump(data, stream)    # Write a YAML representation of data to 'document.yaml'.
>>> print yaml.dump(data)      # Output the document to the screen.
}}}

If you need to dump several YAML documents to a single stream, use the function
'''`yaml.dump_all`'''. '''`yaml.dump_all`''' accepts a list or a generator producing
Java objects to be serialized into a YAML document. The second optional argument is
an open file.

{{{
#!python
>>> print yaml.dump([1,2,3], explicit_start=True)
--- [1, 2, 3]

>>> print yaml.dump_all([1,2,3], explicit_start=True)
--- 1
--- 2
--- 3
}}}

You may even dump instances of Java classes.

{{{
#!python
>>> class Hero:
...     def __init__(self, name, hp, sp):
...         self.name = name
...         self.hp = hp
...         self.sp = sp
...     def __repr__(self):
...         return "%s(name=%r, hp=%r, sp=%r)" % (
...             self.__class__.__name__, self.name, self.hp, self.sp)

>>> print yaml.dump(Hero("Galain Ysseleg", hp=-3, sp=2))

!!python/object:__main__.Hero {hp: -3, name: Galain Ysseleg, sp: 2}
}}}

'''`yaml.dump`''' supports a number of keyword arguments that specify
formatting details for the emitter. For instance, you may set the
preferred intendation and width, use the canonical YAML format or
force preferred style for scalars and collections.
{{{
#!python
>>> print yaml.dump(range(50))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 45, 46, 47, 48, 49]

>>> print yaml.dump(range(50), width=50, indent=4)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
    28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
    40, 41, 42, 43, 44, 45, 46, 47, 48, 49]

>>> print yaml.dump(range(5), canonical=True)
---
!!seq [
  !!int "0",
  !!int "1",
  !!int "2",
  !!int "3",
  !!int "4",
]

>>> print yaml.dump(range(5), default_flow_style=False)
- 0
- 1
- 2
- 3
- 4

>>> print yaml.dump(range(5), default_flow_style=True, default_style='"')
[!!int "0", !!int "1", !!int "2", !!int "3", !!int "4"]
}}}


=== Constructors, representers, resolvers ===

You may define your own application-specific tags. The easiest way to do it is
to define a subclass of '''`yaml.YAMLObject`''':
{{{
>>> class Monster(yaml.YAMLObject):
...     yaml_tag = u'!Monster'
...     def __init__(self, name, hp, ac, attacks):
...         self.name = name
...         self.hp = hp
...         self.ac = ac
...         self.attacks = attacks
...     def __repr__(self):
...         return "%s(name=%r, hp=%r, ac=%r, attacks=%r)" % (

...             self.__class__.__name__, self.name, self.hp, self.ac, self.attacks)
}}}

The above definition is enough to automatically load and dump `Monster` objects:
{{{
#!python
>>> yaml.load("""
... --- !Monster
... name: Cave spider
... hp: [2,6]    # 2d6
... ac: 16
... attacks: [BITE, HURT]
... """)

Monster(name='Cave spider', hp=[2, 6], ac=16, attacks=['BITE', 'HURT'])

>>> print yaml.dump(Monster(
...     name='Cave lizard', hp=[3,6], ac=16, attacks=['BITE','HURT']))

!Monster
ac: 16
attacks: [BITE, HURT]
hp: [3, 6]
name: Cave lizard
}}}

'''`yaml.YAMLObject`''' uses metaclass magic to register a constructor, which
transforms a YAML node to a class instance, and a representer, which serializes
a class instance to a YAML node.

If you don't want to use metaclasses, you may register your constructors
and representers using the functions '''`yaml.add_constructor`''' and
'''`yaml.add_representer`'''. For instance, you may want to add a constructor
and a representer for the following '''`Dice`''' class:
{{{
#!python
>>> class Dice(tuple):
...     def __new__(cls, a, b):
...         return tuple.__new__(cls, [a, b])
...     def __repr__(self):
...         return "Dice(%s,%s)" % self

>>> print Dice(3,6)
Dice(3,6)
}}}


The default representation for '''`Dice`''' objects is not nice:
{{{
#!python
>>> print yaml.dump(Dice(3,6))

!!python/object/new:__main__.Dice
- !!python/tuple [3, 6]
}}}

Suppose you want a '''`Dice`''' object to represented as '''`AdB`''' in YAML:
{{{
#!python
>>> print yaml.dump(Dice(3,6))

3d6
}}}

First we define a representer that convert a dice object to scalar node
with the tag `!dice` and register it.
{{{
#!python
>>> def dice_representer(dumper, data):
...     return dumper.represent_scalar(u'!dice', u'%sd%s' % data)

>>> yaml.add_representer(Dice, dice_representer)
}}}

Now you may dump an instance of the `Dice` object:
{{{
#!python
>>> print yaml.dump({'gold': Dice(10,6)})
{gold: !dice '10d6'}
}}}

Let us add the code to construct a Dice object:
{{{
#!python
>>> def dice_constructor(loader, node):
...     value = loader.construct_scalar(node)
...     a, b = map(int, value.split('d'))
...     return Dice(a, b)

>>> yaml.add_constructor(u'!dice', dice_constructor)
}}}

Then you may load a `Dice` object as well:
{{{
#!python
>>> print yaml.load("""
... initial hit points: !dice 8d4
... """)

{'initial hit points': Dice(8,4)}
}}}

You might want to not specify the tag `!dice` everywhere. There is a way
to teach PyYAML that any untagged plain scalar that looks like XdY has
the implicit tag `!dice`. Use '''`add_implicit_resolver`''':
{{{
#!python
>>> import re
>>> pattern = re.compile(r'^\d+d\d+$')
>>> yaml.add_implicit_resolver(u'!dice', pattern)
}}}

Now you don't have to specify the tag to define a `Dice` object:
{{{
#!python
>>> print yaml.dump({'treasure': Dice(10,20)})

{treasure: 10d20}

>>> print yaml.load("""
... damage: 5d10
... """)

{'damage': Dice(5,10)}
}}}


== YAML syntax ==


A good introduction to the YAML syntax is
[http://yaml.org/spec/cvs/current.html#id857168 Chapter 2 of the YAML specification].

You may also check [http://yaml4r.sourceforge.net/cookbook/ the YAML cookbook]. Note
that it is focused on a Ruby implementation and uses the old YAML 1.0 syntax.

Here we present most common YAML constructs together with the corresponding Java objects.


=== Documents ===

YAML stream is a collection of zero or more documents. An empty stream contains no documents.
Documents are separated with '''`---`'''. Documents may optionally end with '''`...`'''.
A single document may or may not be marked with '''`---`'''.

Example of an implicit document:
{{{
- Multimedia
- Internet
- Education
}}}

Example of an explicit document:
{{{
---
- Afterstep
- CTWM
- Oroborus
...
}}}

Example of several documents in the same stream:
{{{
---
- Ada
- APL
- ASP

- Assembly
- Awk
---
- Basic
---
- C
- C#    # Note that comments are denoted with ' #' (space and #).
- C++
- Cold Fusion
}}}


=== Block sequences ===

In the block context, sequence entries are denoted by '''`- `''' (dash and space):
{{{
# YAML
- The Dagger 'Narthanc'
- The Dagger 'Nimthanc'
- The Dagger 'Dethanc'
}}}
{{{
# Java
["The Dagger 'Narthanc'", "The Dagger 'Nimthanc'", "The Dagger 'Dethanc'"]
}}}

Block sequences can be nested:
{{{
# YAML
-
  - HTML
  - LaTeX
  - SGML
  - VRML
  - XML
  - YAML
-
  - BSD
  - GNU Hurd
  - Linux
}}}
{{{
# Java
[['HTML', 'LaTeX', 'SGML', 'VRML', 'XML', 'YAML'], ['BSD', 'GNU Hurd', 'Linux']]
}}}

It's not necessary to start a nested sequence with a new line:
{{{
# YAML
- 1.1
- - 2.1
  - 2.2
- - - 3.1
    - 3.2
    - 3.3
}}}
{{{
# Java
[1.1, [2.1, 2.2], [[3.1, 3.2, 3.3]]]
}}}

A block sequence may be nested to a block mapping. Note that in this
case it is not necessary to indent the sequence.
{{{
# YAML
left hand:
- Ring of Teleportation
- Ring of Speed

right hand:
- Ring of Resist Fire
- Ring of Resist Cold
- Ring of Resist Poison
}}}
{{{
# Java
{'right hand': ['Ring of Resist Fire', 'Ring of Resist Cold', 'Ring of Resist Poison'],
'left hand': ['Ring of Teleportation', 'Ring of Speed']}
}}}


=== Block mappings ===

In the block context, keys and values of mappings are separated by '''`: `''' (colon and space):
{{{
# YAML
base armor class: 0
base damage: [4,4]
plus to-hit: 12
plus to-dam: 16
plus to-ac: 0
}}}
{{{
# Java
{'plus to-hit': 12, 'base damage': [4, 4], 'base armor class': 0, 'plus to-ac': 0, 'plus to-dam': 16}
}}}

Complex keys are denoted with '''`? `''' (question mark and space):
{{{
# YAML
? !!python/tuple [0,0]
: The Hero
? !!python/tuple [0,1]
: Treasure
? !!python/tuple [1,0]
: Treasure
? !!python/tuple [1,1]
: The Dragon
}}}
{{{
# Java
{(0, 1): 'Treasure', (1, 0): 'Treasure', (0, 0): 'The Hero', (1, 1): 'The Dragon'}
}}}

Block mapping can be nested:
{{{
# YAML
hero:
  hp: 34
  sp: 8
  level: 4
orc:
  hp: 12
  sp: 0
  level: 2
}}}
{{{
# Java
{'hero': {'hp': 34, 'sp': 8, 'level': 4}, 'orc': {'hp': 12, 'sp': 0, 'level': 2}}
}}}

A block mapping may be nested in a block sequence:
{{{
# YAML
- name: PyYAML
  status: 4
  license: MIT
  language: Python
- name: PySyck
  status: 5
  license: BSD
  language: Python
}}}
{{{
# Java
[{'status': 4, 'language': 'Python', 'name': 'PyYAML', 'license': 'MIT'},
{'status': 5, 'license': 'BSD', 'name': 'PySyck', 'language': 'Python'}]
}}}


=== Flow collections ===

The syntax of flow collections in YAML is very close to the syntax of list and
dictionary constructors in Python:
{{{
# YAML
{ str: [15, 17], con: [16, 16], dex: [17, 18], wis: [16, 16], int: [10, 13], chr: [5, 8] }
}}}
{{{
# Java
{'dex': [17, 18], 'int': [10, 13], 'chr': [5, 8], 'wis': [16, 16], 'str': [15, 17], 'con': [16, 16]}
}}}


=== Scalars ===

There are 5 styles of scalars in YAML: plain, single-quoted, double-quoted, literal, and folded:
{{{
# YAML
plain: Scroll of Remove Curse
single-quoted: 'EASY_KNOW'
double-quoted: "?"
literal: |    # Borrowed from http://www.kersbergen.com/flump/religion.html
  by hjw              ___
     __              /.-.\
    /  )_____________\\  Y
   /_ /=== == === === =\ _\_
  ( /)=== == === === == Y   \
   `-------------------(  o  )
                        \___/
folded: >
  It removes all ordinary curses from all equipped items.
  Heavy or permanent curses are unaffected.
}}}
{{{
# Java
{'plain': 'Scroll of Remove Curse',
'literal':
    'by hjw              ___\n'
    '   __              /.-.\\\n'
    '  /  )_____________\\\\  Y\n'
    ' /_ /=== == === === =\\ _\\_\n'
    '( /)=== == === === == Y   \\\n'
    ' `-------------------(  o  )\n'
    '                      \\___/\n',
'single-quoted': 'EASY_KNOW',
'double-quoted': '?',
'folded': 'It removes all ordinary curses from all equipped items. Heavy or permanent curses are unaffected.\n'}
}}}

Each style has its own quirks. A plain scalar does not use indicators to denote its
start and end, therefore it's the most restricted style. Its natural applications are
names of attributes and parameters.

Using single-quoted scalars, you may express any value that does not contain special characters.
No escaping occurs for single quoted scalars except that duplicate quotes '''`''`''' are replaced
with a single quote '''`'`'''.

Double-quoted is the most powerful style and the only style that can express any scalar value.
Double-quoted scalars allow ''escaping''. Using escaping sequences '''`\x**`''' and '''`\u****`''',
you may express any ASCII or Unicode character.

There are two kind of block scalar styles: '''literal''' and '''folded'''. The literal style is
the most suitable style for large block of text such as source code. The folded style is similar
to the literal style, but two consequent non-empty lines are joined to a single line separated
by a space character.


=== Aliases ===

Using YAML you may represent objects of arbitrary graph-like structures. If you want to refer
to the same object from different parts of a document, you need to use anchors and aliases.

Anchors are denoted by the '''`&`''' indicator while aliases are denoted by '''`*`'''. For instance,
the document
{{{
left hand: &A
  name: The Bastard Sword of Eowyn
  weight: 30
right hand: *A
}}}
expresses the idea of a hero holding a heavy sword in both hands.

SnakeYAML now fully supports recursive objects. For instance, the document 
{{{
&A [ *A ]
}}}
will produce a list object containing a reference to itself.


=== Tags ===

Tags are used to denote the type of a YAML node. Standard YAML tags are defined at
http://yaml.org/type/index.html.

Tags may be implicit:
{{{
boolean: true
integer: 3
float: 3.14
}}}
{{{
#!python
{'boolean': True, 'integer': 3, 'float': 3.14}
}}}

or explicit:
{{{
boolean: !!bool "true"
integer: !!int "3"
float: !!float "3.14"
}}}
{{{
#!python
{'boolean': True, 'integer': 3, 'float': 3.14}
}}}

Plain scalars without explicitly defined tag are subject to implicit tag
resolution. The scalar value is checked against a set of regular expressions
and if one of them matches, the corresponding tag is assigned to the scalar.
SnakeYAML allows an application to add custom implicit tag resolvers.


== YAML tags and Java types ==

The following table describes how nodes with different tags are converted
to Java objects.

|| '''YAML tag'''                  ||   '''Java type'''   ||
|| ''Standard YAML tags''          ||                     ||
|| `!!null`                        || `null`              ||
|| `!!bool`                        || `Boolean`           ||
|| `!!int`                         || `Long`              ||
|| `!!float`                       || `Double`            ||
|| `!!binary`                      || `String`            ||
|| `!!timestamp`                   || `java.util.Date`    ||
|| `!!omap`, ``!!pairs``           || `List` of `Object[]`||
|| `!!set`                         || `Set`               ||
|| `!!str`                         || `Srting`            ||
|| `!!seq`                         || `List`              ||
|| `!!map`                         || `Map`               ||

== Deviations from the specification ==

''need to update this section''

 * rules for tabs in YAML are confusing. We are close, but not there yet.
   Perhaps both the spec and the parser should be fixed. Anyway, the best
   rule for tabs in YAML is to not use them at all.
 * Byte order mark. The initial BOM is stripped, but BOMs inside the stream
   are considered as parts of the content. It can be fixed, but it's not
   really important now.
 * ~~Empty plain scalars are not allowed if alias or tag is specified.~~ This
   is done to prevent anomalities like '''[ !tag, value]''', which can be
   interpreted both as '''[ !<!tag,> value ]''' and '''[ !<!tag> "", "value" ]'''.
   The spec should be fixed.
 * Indentation of flow collections. The spec requires them to be indented
   more than their block parent node. Unfortunately this rule renders many intuitively
   correct constructs invalid, for instance,
{{{
block: {
} # this is indentation violation according to the spec.
}}}
 * ':' is not allowed for plain scalars in the flow mode. ~~~'''{1:2}''' is
   interpreted as '''{ 1 : 2 }'''.~~~


== Notes ==

To do and long-term goals:
 * better JavaBeans support
